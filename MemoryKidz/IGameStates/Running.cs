using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using Microsoft.Xna.Framework.Input;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using System.Threading;
using System.Diagnostics;
using Microsoft.Xna.Framework.Audio;

/// Running-class by Marvin Karaschewski
/// Holds the logic which handles the game with input and output
/// Makes use of the IGameState-System

namespace MemoryKidz
{
    /// <summary>
    /// Logic which runs the actual game and handles all input and output
    /// </summary>
    public class Running : IGameState
    {
        GraphicsDevice g;
        List<Card> cardList;
        List<Button> bl;

        MouseState currentState;
        MouseState lastState;

        Texture2D background;
        Texture2D backside;
        Texture2D correct;
        Texture2D backArrow;
        Texture2D backArrow_select;

        // Declares all used Sounds
        SoundEffect backgroundMusicFile;
        SoundEffectInstance backgroundMusic;

        // Height of device in pixel
        int hZero;
        // Width of device in pixel
        int bZero;

        public void LoadContent()
        {
            g = new GraphicsDevice();

            // Loads all the used Texture-Files through the Content-Pipeline
            background = Texture2D.FromStream(g, TitleContainer.OpenStream("Content/Textures/Others/bg_1080p.png"));
            backside = Texture2D.FromStream(g, TitleContainer.OpenStream("Content/Textures/Cardset2/card_back2.png"));
            correct = Texture2D.FromStream(g, TitleContainer.OpenStream("Content/Textures/Cardset2/card_tick3.png"));
            backArrow = Texture2D.FromStream(g, TitleContainer.OpenStream("Content/Textures/Buttons/BackArrow.png"));
            backArrow_select = Texture2D.FromStream(g, TitleContainer.OpenStream("Content/Textures/Buttons/BackArrow_select.png"));

            // Loads all the used Sound-files through the Content-Pipeline
            backgroundMusicFile = SoundEffect.FromStream(TitleContainer.OpenStream("Content/Sounds/SillyFun.wav"));
            backgroundMusic = new SoundEffectInstance(backgroundMusicFile);

            if (Session.Active == true)
            {
                Extension.ResumeSound();
                cardList = Session.CardList;
            }
            else 
            {
                // Start the Scoretelling
                switch (GameSpecs.Difficulty)
                {
                    case 1:
                        {
                            Timer.Initialize(6000);
                            break;
                        }
                    case 2:
                        {
                            Timer.Initialize(8000);
                            break;
                        }
                    case 3:
                        {
                            Timer.Initialize(10000);
                            break;
                        }
                        


                }


                // Generates a new Set of Cards to begin a new Session
                cardList = GenerateNewCardList();

                // Starts the Timer for Scoretelling
                Timer.StartTimer();

                // Fills the cardList with new cards which are generated by GenerateNewCardList
                cardList.Reverse();
                Session.NewSession(GameSpecs.Difficulty, cardList);
                Session.Active = true;

                // Stops playing old sounds if there are any
                Extension.StopSound();

                // Starts playing new sound...
                Extension.StartSound(ref backgroundMusic);

                // ... and mutes it if the Gamespecs are set to muted
                if (!GameSpecs.MusicOn)
                {
                    Extension.MuteMusic();
                }
            }
        }

        // Loads Texture by any given integer value thats valid for a motive 
        public Texture2D LoadTextureByMotive(int motive)
        {
            // Texture2D texture = Texture2D.FromStream(g, TitleContainer.OpenStream("Content/Textures/Cardset1/motive" + motive + ".png"));

            Texture2D texture = Texture2D.FromStream(g, TitleContainer.OpenStream("Content/Textures/Cardset2/motive" + motive + ".png"));

            return texture;
        }

        /// <summary>
        /// CONSTRUCTOR
        /// </summary>
        public Running(List<Button> btnList)
        {
            bl = btnList;
            foreach (Button btn in bl)
            {
                // ClickTangle makes a new virtual Rectangle which is not painted, but virtually overlayed to catch clicks provided by the user. 
                btn.ClickTangle = new Rectangle((int)btn.Position.X, (int)btn.Position.Y, btn.SourceRectangle.Width, btn.SourceRectangle.Height);
            }
        }

        public GameState Update(Microsoft.Xna.Framework.GameTime gameTime)
        {
            KeyboardState kbState = Keyboard.GetState();

            lastState = currentState;
            currentState = Mouse.GetState();

            // Current Position of the mouse-cursor
            Point p = new Point(currentState.X, currentState.Y);

            // Hover-Check-Routine for the Button(s)
            if (bl[0].ClickTangle.Contains(new Point(currentState.X, currentState.Y)))
            {
                bl[0].Texture = backArrow_select;
            }
            else
            {
                bl[0].Texture = backArrow;
            }

            // Starts to run down the Highscore if the Timer is active
            if (Timer.Running == true)
            {
                if (Timer.GetScore() > 0.0)
                {
                    // Use timer to determine the Score
                    Timer.Score -= gameTime.ElapsedGameTime.TotalMilliseconds / 60;
                }
            }

            /// <summary>
            /// Ends the Game if the score hits 0 while gaming
            /// </summary>
            if (Timer.Score == 0)
            {
                Thread.Sleep(200);
                Session.Gameover = true;
                return GameState.Endgame;
            }

            /// <summary>
            /// Checks if the players have won the game (a.k.a. matched all possible pairs)
            /// </summary>
            if (Session.PairsUntilWin == 0)
            {
                Timer.StopTimer();

                Thread.Sleep(200);
                /// Implement optional winning-sound-playing here

                // Returns the Endgame state if the players have turned all cards correctly within the given time
                return GameState.Endgame;
            }

            // Temporary solution to get to the highscores prematurely
            if (kbState.IsKeyDown(Keys.F))
            {
                return GameState.Highscore;
            }

            // Temporary solution to get to the Success-Screen prematurely
            if (kbState.IsKeyDown(Keys.H))
            {
                Countdown.Initialize(10);
                return GameState.Endgame;
            }

            /// <summary>
            /// Checks if the players paired up two cards of the same kind and runs the according logic
            /// </summary>
            if (Session.TurnedCards.Count == 2)
            {
                Thread.Sleep(200);
                if (Session.TurnedCards[0].MotiveID == Session.TurnedCards[1].MotiveID)
                {
                    cardList[Session.TurnedCards[0].Id].CurrentTexture = correct;
                    cardList[Session.TurnedCards[1].Id].CurrentTexture = correct;
                    Session.ResetTurnedCards();
                    Session.PairsUntilWin--;
                    Thread.Sleep(200);
                }
                else
                {
                    cardList[Session.TurnedCards[0].Id].CurrentTexture = backside;
                    cardList[Session.TurnedCards[1].Id].CurrentTexture = backside;
                    Session.ResetTurnedCards();
                    Thread.Sleep(200);
                }
            }

            // Click-Check-Routine
            if (currentState.LeftButton == ButtonState.Released && lastState.LeftButton == ButtonState.Pressed)
            {
                // Button to return to MainMenu-Screen
                if (bl[0].ClickTangle.Contains(new Point(currentState.X, currentState.Y)))
                {
                    Extension.PlaySoundEffect("menuClick");
                    g.Clear(Color.Black);
                    Thread.Sleep(20);
                    return GameState.MainMenuSession;
                }

                Thread.Sleep(20);
                int index = 0;
                foreach (Card c in cardList)
                {
                    if (c.Zone.Contains(p))
                    {
                        Extension.PlaySoundEffect("cardFlip");
                        // Performs a check if a card is already turned before running the Gamelogic for turning
                        if (c.CurrentTexture != correct)
                        {
                            switch (Session.TurnedCards.Count)
                            {
                                case 0:
                                    {
                                        c.CurrentTexture = LoadTextureByMotive(c.MotiveID);
                                        c.Id = index;
                                        Session.TurnedCards.Add(c);
                                        Thread.Sleep(20);
                                        break;
                                    }

                                case 1:
                                    {
                                        if (c.Id != Session.TurnedCards[0].Id)
                                        {
                                            c.CurrentTexture = LoadTextureByMotive(c.MotiveID);
                                            c.Id = index;
                                            Session.TurnedCards.Add(c);
                                            Thread.Sleep(20);
                                            break;
                                        }
                                        else 
                                        {
                                            index--;
                                            break;
                                        }
                                    }
                            }
                        }
                    }
                    index++;
                }
            }

            // Hover-Implementation to test Card-Zoning
            foreach (Card c in cardList)
            {
                if (c.Zone.Contains(p))
                {
                    GameSpecs.CurrentCard = c.MotiveID;
                }
            }

            // Button-Press to Pause the Game
            if (kbState.IsKeyDown(Keys.Escape))
            {
                Thread.Sleep(100);
                return GameState.MainMenuSession;
            }

            else
            {
                return GameState.Running;
            }
        }

        public void Draw(Microsoft.Xna.Framework.GameTime gameTime, ref SpriteBatch sp, ref GraphicsDeviceManager graphics, ref SpriteFont font)
        {
            sp.Begin();
            g.Clear(Color.Black);
            
            /// Logic for drawing the ActiveBackground
            ActiveBackground.DrawSky();
            ActiveBackground.DrawSunrays();
            ActiveBackground.DrawFlowers();
            ActiveBackground.DrawGrass();
            ActiveBackground.DrawSun();
            ActiveBackground.DrawCloud1();
            ActiveBackground.DrawCloud2();
            ActiveBackground.DrawCloud3();
            ActiveBackground.DrawCloud4();
            ActiveBackground.DrawCloud5();

            // Draws the Background-Image
            // sp.Draw(background, new Rectangle(0, 0, bZero, hZero), Color.White);

            // "Cheating"-Labels: Used for development-purposes only 
            // sp.DrawString(font, GameSpecs.CurrentCard.ToString(), new Vector2((int)(bZero * 0.020), hZero - 80),Color.Violet);
            // sp.DrawString(font, Session.PairsUntilWin.ToString(), new Vector2((int)(bZero * 0.020), hZero - 40), Color.Orange);
            // sp.DrawString(font, Session.TurnedCards.Count.ToString(), new Vector2((int)(bZero * 0.020), hZero - 120), Color.Black);

            // Draw the Button(s)
            foreach (Button btn in bl)
            {
                sp.Draw(btn.Texture, btn.Position, btn.SourceRectangle, btn.Color, btn.Rotation, btn.Origin, btn.Scale, btn.Effect, btn.LayerDepth);
            }

            // The Scoreboard
            sp.DrawString(GameSpecs.scoreFont, Convert.ToInt32(Timer.Score).ToString(), new Vector2((int)(bZero * 0.40), (int)(hZero * 0.011)), Color.OrangeRed);

            GameLogic(ref sp, ref graphics);

            sp.End();
        }

        /// <summary>
        /// Shorthand-Method for filling the List of Dimensions. Just to save Code!
        /// </summary>
        public List<int> FillDimensionList(List<int> dim, int ha, int hb, int hc, int hd, int ba, int bb, int bc, int bd)
        {
            dim.Add(ha);
            dim.Add(hb);
            dim.Add(hc);
            dim.Add(hd);
            dim.Add(ba);
            dim.Add(bb);
            dim.Add(bc);
            dim.Add(bd);

            return dim;
        }

        /// <summary>
        /// Generates a new List of Card-Objects for Test-purposes
        /// </summary>
        /// <returns>List of Cards</returns>
        public List<Card> GenerateNewCardList()
        {
            // List of Cards to be returned
            List<Card> cardList = new List<Card>();

            // List of integer-value which represent the motive/symbol on the Card
            List<int> motiveList = new List<int>();

            Random r = new Random(DateTime.Now.Millisecond);
 
            // Number of different motives on the Cards
            int motiveCounter = 0;

            // Switches the Difficulty and sets an appropriate Motive-Counter
            switch (GameSpecs.Difficulty)
            {
                case 1:
                {
                    motiveCounter = 8;
                    break;
                }
                case 2:
                {
                    motiveCounter = 12;
                    break;
                }
                case 3:
                {
                    motiveCounter = 18;
                    break;
                }
            }

            // Generates a matching list of integers
            while (motiveCounter > 0)
            {
                int next = r.Next(1, 19);
                if (motiveList.Contains(next))
                {
                    next = r.Next(1, 19);
                }
                else
                {
                    motiveList.Add(next);
                    motiveCounter--;
                }
            }

            int cardCounter = motiveList.Count * 2;

            // Generator-Code for the new Card-Items
            for (int i = cardCounter; i > 0; i-=2)
            {
                Card newCard = new Card(i, motiveList[(i / 2) - 1], backside);
                Card newCard2 = new Card(i-1, motiveList[(i / 2) - 1], backside);

                cardList.Add(newCard);
                cardList.Add(newCard2);
            }

            Extension.Shuffle(cardList);

            return cardList;
        }

        /// <summary>
        /// Calculates the dimensions of the interface-elements in accordance to the layout which is chosen by difficulty
        /// </summary>
        /// <returns>List of integer values: ha, hb, hc, hd, ba, bb, bc, bd</returns>
        public List<int> CalculateDimensionsInPixel(int difficulty, ref GraphicsDeviceManager graphics)
        {
            graphics.PreferredBackBufferWidth = GraphicsAdapter.DefaultAdapter.CurrentDisplayMode.Width;
            graphics.PreferredBackBufferHeight = GraphicsAdapter.DefaultAdapter.CurrentDisplayMode.Height;
            hZero = graphics.PreferredBackBufferHeight;
            bZero = graphics.PreferredBackBufferWidth;

            List<int> dimensions = new List<int>();
            int ha, hb, hc, hd, ba, bb, bc, bd;

            switch (difficulty)
            {
                // Difficulty 1 (4x4)
                case 1:
                    {
                        ha = (int)Math.Round((double)hZero * 0.2454);
                        hb = (int)Math.Round((double)hZero * 0.5093);
                        hc = (int)Math.Round((double)hZero * 0.1065);
                        hd = (int)Math.Round((double)hZero * 0.0278);
                        ba = (int)Math.Round((double)bZero * 0.3099);
                        bb = (int)Math.Round((double)bZero * 0.3802);
                        bc = (int)Math.Round((double)bZero * 0.0833);
                        bd = (int)Math.Round((double)bZero * 0.0156);

                        dimensions = FillDimensionList(dimensions, ha, hb, hc, hd, ba, bb, bc, bd);

                        break;
                    }

                // Difficulty 2 (6x4)
                case 2:
                    {
                        ha = (int)Math.Round((double)hZero * 0.2454);
                        hb = (int)Math.Round((double)hZero * 0.5093);
                        hc = (int)Math.Round((double)hZero * 0.1065);
                        hd = (int)Math.Round((double)hZero * 0.0278);
                        ba = (int)Math.Round((double)bZero * 0.2109);
                        bb = (int)Math.Round((double)bZero * 0.5781);
                        bc = (int)Math.Round((double)bZero * 0.0833);
                        bd = (int)Math.Round((double)bZero * 0.0156);

                        dimensions = FillDimensionList(dimensions, ha, hb, hc, hd, ba, bb, bc, bd);

                        break;
                    }

                // Difficulty 3 (6x6)
                case 3:
                    {
                        ha = (int)Math.Round((double)hZero * 0.1111);
                        hb = (int)Math.Round((double)hZero * 0.7777);
                        hc = (int)Math.Round((double)hZero * 0.1065);
                        hd = (int)Math.Round((double)hZero * 0.0278);
                        ba = (int)Math.Round((double)bZero * 0.2109);
                        bb = (int)Math.Round((double)bZero * 0.5781);
                        bc = (int)Math.Round((double)bZero * 0.0833);
                        bd = (int)Math.Round((double)bZero * 0.0156);

                        dimensions = FillDimensionList(dimensions, ha, hb, hc, hd, ba, bb, bc, bd);

                        break;
                    }
            }
            return dimensions;
        }

        public void GameLogic(ref SpriteBatch sp, ref GraphicsDeviceManager graphics)
        {
            // Loop-Variable modificator
            int i = cardList.Count - 1;

            // Get Dimensions / Positions for the Layout;
            // ha -> Vertical / Top and Bottom [0]
            // hb -> Vertical / Middle Part [1]
            // hc -> Vertical / Tile [2]
            // hd -> Vertical / Space between Tiles [3]
            // ba -> Horizontal / Sides [4]
            // bb -> Horizontal / Middle Part [5]
            // bc -> Horizontal / Tile [6]
            // bd -> Horizontal / Space between Tiles [7]
            List<int> dimension = CalculateDimensionsInPixel(GameSpecs.Difficulty, ref graphics);

            // Starting Positons X/Y to start drawing
            int x = dimension[4];
            int y = dimension[0];

            // Draws the elements in the cardList according to the layout which depends on the difficulty
            switch (GameSpecs.Difficulty)
            {
                case 1:
                {
                    // Number of cards in a row.
                    int rowLength = 4;

                    foreach (Card c in cardList)
                    {
                        c.Zone = new Rectangle(x, y, dimension[6], dimension[2]);
                        sp.Draw(c.CurrentTexture, c.Zone, Color.White);

                        if (rowLength > 1)
                        {
                            x += (dimension[6] + dimension[7]);
                            rowLength--;
                            i--;
                        }
                        else
                        {
                            x = dimension[4];
                            y += (dimension[2] + dimension[3]);
                            rowLength = 4;
                            i--;
                        }
                    }
                    break;
                }

                case 2:
                {
                    // Number of cards in a row.
                    int rowLength = 6;

                    foreach (Card c in cardList)
                    {
                        c.Zone = new Rectangle(x, y, dimension[6], dimension[2]);
                        sp.Draw(c.CurrentTexture, c.Zone, Color.White);

                        if (rowLength > 1)
                        {
                            x += (dimension[6] + dimension[7]);
                            rowLength--;
                            i--;
                        }
                        else
                        {
                            x = dimension[4];
                            y += (dimension[2] + dimension[3]);
                            rowLength = 6;
                            i--;
                        }
                    }
                    break;
                }

                case 3:
                {
                    // Number of cards in a row.
                    int rowLength = 6;

                    // Offset to let the layout move a bit to the bottom to make room for the scoreboard
                    y = (int)((float)y + hZero * 0.080);
                    //y = (int)((float)y + y * 0.081);

                    foreach (Card c in cardList)
                    {
                        
                        c.Zone = new Rectangle(x, y, dimension[6], dimension[2]);
                        sp.Draw(c.CurrentTexture, c.Zone, Color.White);

                        if (rowLength > 1)
                        {
                            x += (dimension[6] + dimension[7]);
                            rowLength--;
                            i--;
                        }
                        else
                        {
                            x = dimension[4];
                            y += (dimension[2] + dimension[3]);
                            rowLength = 6;
                            i--;
                        }
                    }
                    break;
                }
            }
        }

        public void Unload()
        {

        }

        public void Dispose()
        {

        }

    }
}